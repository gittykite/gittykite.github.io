---
title: HTTP 완벽가이드 - 2. 연결 및 서버 아키텍처
category: 통신/보안
tags:
  - HTTP
---

## 4장 커넥션 관리

### TCP 커넥션
: 패킷 교환 네트워크 프로토콜의 계층화된 집합
+ 연결과정

  ||
  |---|
  |1. 브라우저가 URL의 호스트명 추출 |
  |2. 추출된 호스트명의 IP주소 검색 |
  |3. 브라우저가 URL의 포트번호를 취득 |
  |4. 취득한 IP주소와 포트로 TCP 커넥션 생성 |
  |5. 서버로 HTTP 요청 메세지 전송 |
  |6. 서버로부터 HTTP 응답 메세지 수신 |
  |7. 브라우저가 커넥션을 종료 |

+ 특성  

  |명칭|상세|
  |---|---|
  | 신뢰성 | 충돌없이 데이터를 순서대로 정확하게 전달 <br> => PC/네트워크에 문제 없는 한 안전한 전송 보장
  | 병렬성 | 서로 다른 포트를 이용해 여러 TCP 커넥션 구축
  | 유일성 | 발신지IP + 발신지포트 + 수신지IP + 수신지포트 <br> => 유일한 커넥션 조합

+ 패킷
  - 데이터를 세그먼트 단위로 나누고 이를 패킷에 담아 전달  
  ![](https://media.geeksforgeeks.org/wp-content/uploads/TCPSegmentHeader-1.png)
  - 참고: [TCP헤더구조](https://evan-moon.github.io/2019/11/10/header-of-tcp/)
+ 계층

  |HTTP 계층|HTTPS 계층|상세|
  |---|---|---|
  |HTTP |HTTP |어플리케이션 계층 |
  |- |TLS/SSL |보안 계층 |
  |TCP |TCP |전송계층 |
  |IP |IP |네트워크 계층 |
  |Network <br> Interface |Network <br> Interface |데이터링크 계층 |

+ 소켓 API 
  - 공통함수
  
    |함수|상세|
    |---|---|
    |socket() |새로운 소켓 생성 (미연결) |
    |bind() |소켓에 로컬 포트 및 인터페이스 할당 |
    |connect() |로컬 소켓과 원격 호스트 사이에 TCP연결 생성 |
    |listen() |로컬 소켓이 연결 요청 수신하도록 허용 |
    |accept() |로컬포트에 연결 성립되는 걸 대기 |
    |read() |소켓이 버퍼에 읽기 시도 |
    |write() |소켓이 버퍼에 쓰기 시도 |
    |close() |TCP 연결 종료 |
    |shutdown() |TCP 연결 입출력만 닫음 |
    |getsockopt() |로컬 소켓 설정값 취득 |
    |setsockopt() |로컬 소켓 설정값 설정 |

    * 참고: [파이썬 예제](https://velog.io/@gwak2837/네트워크-응용-설계-소켓-API) 

  - 연결과정
    
    |주체|처리|
    |---|---|
    |서버 | - socket: 소켓생성 <br> - bind: 포트 설정 <br> - listen: 연결 허용 <br> - accept: 연결 대기 |
    |클라이언트 | - IP/포트 취득 <br> - socket: 소켓생성 <br> - connect: 서버에 연결요청|
    |서버 | - 연결성립 통지 <br> - read: 요청 읽기(대기)|
    |클라이언트 | - 연결성공 <br> - write: HTTP요청 전송 <br> -read: HTTP응답 읽기(대기)|
    |서버 | - HTTP요청 처리 <br> - write: HTTP응답 전송 <br> - close: 연결 닫기|
    |클라이언트 | - HTTP응답 처리 <br> - close: 연결 닫기|

### HTTP 커넥션 지연
+ HTTP 트랜잭션 지연 요소
  - 하드웨어 성능
  - 네트워크/서버 전송속도
  - 요청/응답 메세지 크기
  - 클라이언트-서버 간 거리
  - TCP의 기술적 복잡성 
+ TCP 성능 요소
 
 |명칭|상세|특성|
 |---|---|---|
 |TCP 커넥션 <br> 핸드셰이크 | 커넥션 생성 위한 <br> SYN/SYN+ACK 패킷 교환 | 매 생성마다 지연 발생|
  |TCP 확인응답 편승 | 데이터 송출 패킷 있을 경우 <br>확인응답 패킷을 편승(piggyback) | 효율적이나 지연 발생|
  | TCP slow-start | 데이터 전송 성공한 커넥션에 높은 속도(전송가능 패킷 수) 허용 | 혼잡제어 효과|
  | nagle 알고리즘 | 작은 패킷은 버퍼에 저장해 한꺼번에 전송 <br> <-> [silly window synndrome](https://programming119.tistory.com/147)  | - 작은 메세지의 긴 지연 <br> - 확인응답 편승 지연 악화 <br> - TCP_NODELAY 파라미터로 off 가능 |
  |TIME_WAIT 지연 및 포트 고갈 |커넥션 종료 시 일정 기간(2MSL) 재연결 방지 | - 이전 커넥션 패킷 유입 방지 <br> - 성능시험 시 발생 가능|
  - silly window syndrome  
    : 1 Byte 패킷 대량 전송하는 반사회적 전송행위
  - 포트고갈  
    : 초당 요청량이 트랜잭션 처리량 초과시 새로운 포트 이용 불가  
    => 가상 IP로 이용가능 커넥션(IP+포트) 조합 증설 필요  
  - 2MSL  
    : 라우터의 세그먼트 생명주기 * 2 (=2분에서 줄어듬)

### HTTP 커넥션 관리
+ Connection 헤더  
  : 트랜잭션 종류 후 연결유지 여부 결정
  - close  
  : 메세지 전송 후 연결 종료 
  - 쉼표로 구분된 HTTP 헤더 목록 (보통 keep-alive만 해당)  
  : 발신자와 첫 번째 기기와의 연결을 정의 (포워드 시 삭제)  
+ 순차처리
  - 객체크기 모름 => 로딩 중에 화면 표시 불가 =>사용자가 심리적 지연 느낌
+ 병렬 커넥션  
  : 동시에 여러 개의 TCP 커넥션 이용
  
  |장점|단점|
  |---|---| 
  |대역폭 충분 + 지연시간 겹침 <br> => 총 지연시간 감소 가능 | 커넥션 생성 지연 <br> 메모리 부하 발생 가능| 

+ 지속 커넥션   
  : 서버나 클라이언트가 연결 종료하기 전까지는 커넥션 재사용  
  => 생성 지연 제거 but 커넥션 쌓이지 않도록 관리 필수
  
  |명칭|상세|
  |---|---|
  |HTTP/1.0+ Keep-Alive | - HTTP1.1에서 제거 <br> - 강제성 없음 (응답헤더에 없으면 거절로 인식) <br> - 본문 길이값 알거나 chunk 전송 인코딩 써야 유지 가능 <br> 예) Connection: Keep-Alive <br> Keep-Alive: timeout=120, max=5 |
  |HTTP/1.1 Persistent | - 기본값: 종료 헤더 전달 전까지 연결 지속 <br> - 강제성 없음 (Connection: close 없어도 종료 가능) <br> - 본문 길이값 알거나 chunk 전송 인코딩 필요 <br> - 과부하 방지: 클라이언트가 2개 정도 유지하는 게 바람직|
  |HTTP/1.1 Pipelining| - 기본 비활성화: 지속커넥션일 때만 이용 가능 <br> - 응답 기다리지 않고 요청 계속 전달 <br> - 순서대로 비멱등 요청만 발송해야|
  |HTTP/2.0 Multiplexing| -단일 커넥션 내에서 다중화 <br>=> 프레임화된 여러 메세지 스트림을 동시적으로 전송  |

  ![](https://mdn.mozillademos.org/files/13727/HTTP1_x_Connections.png)

  - 멍청한(dumb) 프록시 문제
    * Keep-Alive 이해 못하고 그대로 전달 -> 프록시만 커넥션 종료 대기 -> 행 & 타임아웃
    * Proxy-Connection 헤더 이용해도 중간에 멍청한 프록시가 있으면 문제 발생
  - 멱등(idempotent) 요청  
    : 연산 여러 번 수행해도 결과 동일한 요청   ex) GET 조회요청
  - 비멱등(nonidempotent) 요청  
    : 연산마다 결과 달라질 수 있는 요청 ex) POST 가입요청

  ![](https://developers.google.com/web/fundamentals/performance/http2/images/multiplexing01.svg?hl=ko)

  - [구글 HTTP/2 소개](https://developers.google.com/web/fundamentals/performance/http2?hl=ko)
    * 바이너리 프레이밍: HTTP 통신을 바이너리 인코딩된 프레임 교환으로 세분화
    * 스트림: 연결 내에서 전달되는 양방향 바이트 흐름으로 하나 이상의 메시지 전달 가능
    * 메시지: 요청/응답 메시지에 매핑되는 프레임 전체 시퀀스
    * 프레임: HTTP/2 통신의 최소 단위
    * 프레임 헤더: 프레임의 소속 스트림 식별 위한 최소한의 정보
  - [구글 HTTP/2 optimize 슬라이드](https://docs.google.com/presentation/d/1r7QXGYOLCh4fcUq0jDdDwKJWNqWK1o4xMtYpKZCJYjM/present?slide=id.p19)
    * 리소스의 type/context에 따라 스트림의 우선순위(가중치 및 의존도) 결정됨 
    * 각 리소스는 발견 즉시 요청이 생성됨 => 서버가 순서대로 데이터 전송해야
+ 커넥션 종료
  - 언제든지 임의/오류로 종료 가능 => 재시도 등 대응 필요 (비멱등 요청은 예외)
  - Content-Length 불일치 시 서버에 확인 필요
  - 종류

    |명칭|상세|
    |---|---|
    |전체 끊기 | close()로 입/출력 채널 모두 종료 | 
    |절반 끊기 | shutdown()으로 입/출력 채널 중 하나만 종료 <br> => 출력채널만 종료 권장 (종료된 입력채널에 쓰기 오류 방지)| 

    *  connection reset by peer 오류   
    : 종료된 입력채널 전송 시 OS가 버퍼에 저장된 읽히지 않은 데이터 모두 삭제

## 5장 웹 서버

### 웹 서버
+ HTTP 요청처리/응답 + TCP 처리 제공 => 리소스 관리 기능 + 서버 관리(설정/통제/확장) 기능
+ 웹 서버 S/W와 H/W 장비 모두 지칭
+ 기능/형태/크기 다양
  - 다목적 소프트웨어 웹 서버 
    * 네트워크에 연결된 표준 컴퓨터 시스템에서 동작
    * [Netcraft 웹 서버 시장 점유율 (2020.11)](https://news.netcraft.com/archives/2020/11/30/november-2020-web-server-survey.html)
      
      |벤더|점유율|기타|
      |---|---|---|
      |nginx |33.69% |2019.04부터 1위|
      |Apache |26.78% | |
      |Microsoft |7.91% | |
      |Google |3.71% | |
      |Other | 28%| |

  - 임베디드 웹 서버
    * 가전제품 등에 내장되는 소형 웹 서버 => 기기를 웹 브라우저로 관리 가능 
  - 간단한 서버
    * Perl 코드 30줄이면 최소기능 구현 가능 
    
### 웹 서버 통신 과정
+ **1)** 클라이언트 커넥션 수락
  - 1-1) 새 커넥션 수립 (지속커넥션 재사용 시 스킵)
    * 요청받은 TCP 커넥션 연결
    * 커넥션에서 IP주소 추출 + 클라이언트 식별 및 인가
    * 연결 성공 시 커넥션 목록에 추가
  - 1-2) 클라이언트 호스트명 식별 (hostname lookup)
    * 역방향 DNS 사용해 IP를 호스트명으로 변환
    * 접근제어 및 로깅에 사용
    * 지연 발생 가능 => 특정 리소스로 한정 적용 
  - 1-3) 클라이언트 사용자 식별
    * IETF ident 프로토콜 지원 시 사용자 이름 확인 가능  
      => 서버가 클라이언트에게 사용자 이름을 요청 (포트번호: 113)
      => 기본값: 하이픈(-)  
    * 주의!  
      : 지원PC 적음, 지연 발생, 위변조 가능 (폐쇄된 내부망에서만 이용해야)
+ **2)** 요청 메시지 수신
  - 데이터 파싱
    * 순서: 요청메서드, URI, 버전번호, 메세지 헤더, 본문
    * 구분: 개행문자 (CRLF = \r\n)
  - 메세지의 내부 표현
    * 요청메세지 조각 포인터/길이: 내부 자료구조에 저장
    * 헤더: 룩업테이블에 저장  
    * => 신속한 처리/접근 가능 
  - 커넥션 입/출력 처리 아키텍처

    |I/O 아키텍처|상세|
    |---|---|
    |단일-스레드 | 요청을 하나씩 순차적으로 처리 <br> => 낮은 성능|
    |멀티스레드 | - 여러 요청 동시에 처리 <br> - 메모리/리소스 소비 => 개수제한 필요|
    |다중 | - 대량 커넥션을 목록으로 관리 <br> - 처리 필요할 때만 스레드/프로세스 이용|
    |다중 멀티스레드 | - 여러 커넥션을 목록으로 관리 <br> - 처리 시 여러 스레드 동시 이용|

    * 프로세스: 하나의 독립된 제어흐름
    * 스레드: 프로세스의 독립적인 실행 단위
    * 작업풀: 미리 생성된 스레드 집합이 pool에서 대기
    * 참고: [프로세스 vs 스레드](https://velog.io/@yewon-july/Process-vs-Thread) 

+ **3)** 요청 처리
  - 요청의 메소드/리소스/헤더/본문 취득해 처리
+ **4)** 리소스 매핑 및 접근
  - 문서루트(Docroot)
    * 웹콘텐츠를 위해 예약해둔 서버 파일시스템의 특정 폴더   
    * 요청메세지의 URI를 문서루트에 붙여 처리됨  
    * 주의!: 상대주소 공격 가능  
      ex) http://test.kr/../
    * 가상 Docroot  
      : 사이트마다 별도의 문서루트 지정 => IP/호스트명으로 식별 및 처리 
    * 사용자홈 docroots 
      : 사용자마다 홈 디렉토리에 문서루트 지정  ex) ~diana/index.html 
  - 디렉토리 목록
    : 폴더 URL에 대한 일반적인 요청 처리  
    * 에러 반환
    * index 파일 반환  
      ex) Apache DirectoryIndex 설정
    * 탐색된 디렉터리 내용 담은 HTML 반환  
      ex) Apache Options 설정
  - 동적 리소스 매핑  
    : URI를 요청에 따라 콘텐츠 생성하는 프로그램과 연결해 제공  
    ex) Apache의 ScriptAlias, AddHandler 설정
  - 서버사이드 인클루드 (SSI)
    : 리소스의 컨텐츠를 전송 전에 처리  
    ex) 변수값이나 스크립트 출력값 치환   
  - 접근제어
    : 각 리소스에 접근제어 할당 가능
    ex) IP/비밀번호 등 확인
+ **5)** 응답 메세지 생성
  : 리소스 식별 후 요청메서드의 동작 수행 후 응답메세지 반환
  - 응답 엔티티 구성
    * Content-Type 헤더: 응답본문의 MIME타입
    * Content-Length 헤더: 응답본문의 길이 
    * 실제 본문
  - MIME 타입

    |명칭|상세|
    |---|---|
    |mime.types | 확장자에 따라 타입계산|
    |매직 타이핑 <br> Magic typing |패턴테이블(매직파일) 참조 + 파일내용 검사해 타입계산 |
    |유형 명시 <br> Explicit typing | 특정 파일/폴더내 파일에 타입을 일괄 지정 (확장자 무관)|
    |유형 협상 <br> [Type negotiation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation) | 한 리소스를 클라이언트에 맞춰 여러 포맷으로 제공 <br> ex) 언어, 이미지형식, 인코딩|

  - 리다이렉션

    |케이스|상세|상태코드|
    |---|---|---|
    |리소스가 영구히 이동| 클라이언트에게 북마크 갱신 등 안내|301|
    |리소스가 임시로 이동| 리다이렉트 하되 북마크 갱신 방지 안내| 303, 307|
    |URL 증강|문맥정보 포함된 완전한 URL로 리다이렉트|303, 307|
    |부하 균형|과부하 시 타 서버로 리다이렉트 |303, 307|
    |다른 가까운 서버 존재| 클라이언트 정보 지닌 다른 서버로 리다이렉트|303, 307|
    |폴더명 정규화|슬래시(/) 누락 시 추가해 리다이렉트||

+ **6)** 응답 메세지 송신
  - 여러 커넥션 존재 가능 => 커넥션 상태 추적 필요
  - 주의!: 지속커넥션은 Content-Length 계산 및 종료 확인해야
+ **7)** 로깅
  - 트랜잭션이 어떻게 수행되었는지 로그파일에 기록

## 6장 프락시
### 6.1 웹 중개자
### 6.2 왜 프락시를 사용하는가?
### 6.3 프락시는 어디에 있는가?
### 6.4 클라이언트 프락시 설정
### 6.5 프락시 요청의 미묘한 특징들
### 6.6 메시지 추적
### 6.7 프락시 인증
### 6.8 프락시 상호운용성
### 6.9 추가 정보

## 7장 캐시
### 7.1 불필요한 데이터 전송
### 7.2 대역폭 병목
### 7.3 갑작스런 요청 쇄도(Flash Crowds)
### 7.4 거리로 인한 지연
### 7.5 적중과 부적중
### 7.6 캐시 토폴로지
### 7.7 캐시 처리 단계
### 7.8 사본을 신선하게 유지하기
### 7.9 캐시 제어
### 7.10 캐시 제어 설정
### 7.11 자세한 알고리즘
### 7.12 캐시와 광고
### 7.13 추가 정보
